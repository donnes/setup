import type { ConfigHandler, ConfigStatus, ImportResult, ExportResult } from "../types";
import { repoPaths } from "../utils/paths";
import { exists, ensureParentDir } from "../utils/fs";
import { exec } from "../utils/shell";
import { isMacOS, isArch, getPackageManager } from "../utils/platform";
import { writeFileSync, readFileSync } from "fs";

class PackagesConfig implements ConfigHandler {
  name = "packages";
  description = "Package list - Brewfile (macOS) or packages.txt (Arch)";
  systemPath = ""; // Not a file path, generated from system
  repoPath = isMacOS ? repoPaths.brewfile : repoPaths.packages;
  isDirectory = false;

  existsOnSystem(): boolean {
    // Packages always "exist" on system - we can generate the list
    return getPackageManager() !== null;
  }

  existsInRepo(): boolean {
    return exists(this.repoPath);
  }

  isLinked(): boolean {
    // Package files aren't symlinked
    return false;
  }

  async import(): Promise<ImportResult> {
    const pm = getPackageManager();

    if (isMacOS && pm === "brew") {
      return this.importBrewfile();
    } else if (isArch() && (pm === "yay" || pm === "pacman")) {
      return this.importArchPackages();
    }

    return {
      success: false,
      message: "No supported package manager found",
    };
  }

  private async importBrewfile(): Promise<ImportResult> {
    // Generate Brewfile from currently installed packages
    const result = await exec("brew bundle dump --file=-");
    
    if (!result.success) {
      return { success: false, message: "Failed to generate Brewfile: " + result.stderr };
    }

    // Filter to essential packages
    const lines = result.stdout.split("\n");
    const essentialBrewfile = this.filterEssentialBrewPackages(lines);

    ensureParentDir(this.repoPath);
    writeFileSync(this.repoPath, essentialBrewfile);

    return {
      success: true,
      message: "Generated Brewfile with essential packages",
      filesImported: ["Brewfile"],
    };
  }

  private filterEssentialBrewPackages(lines: string[]): string {
    // Essential packages to keep
    const essentialFormulae = new Set([
      "gh",
      "lazygit",
      "fnm",
      "zoxide",
      "eza",
      "atuin",
      "go",
      "rbenv",
      "biome",
      "awscli",
    ]);

    const essentialCasks = new Set([
      "orbstack",
      "raycast",
    ]);

    const essentialTaps = new Set([
      "jesseduffield/lazygit",
    ]);

    const filtered: string[] = [
      "# Brewfile - Essential coding tools",
      "# Generated by ds - edit to customize",
      "",
    ];

    // First pass: collect taps
    const taps: string[] = [];
    const formulae: string[] = [];
    const casks: string[] = [];

    for (const line of lines) {
      const trimmed = line.trim();
      
      if (trimmed.startsWith("tap ")) {
        const match = trimmed.match(/tap\s+"([^"]+)"/);
        if (match && essentialTaps.has(match[1])) {
          taps.push(trimmed);
        }
      } else if (trimmed.startsWith("brew ")) {
        const match = trimmed.match(/brew\s+"([^"]+)"/);
        if (match && essentialFormulae.has(match[1])) {
          formulae.push(`brew "${match[1]}"`);
        }
      } else if (trimmed.startsWith("cask ")) {
        const match = trimmed.match(/cask\s+"([^"]+)"/);
        if (match && essentialCasks.has(match[1])) {
          casks.push(`cask "${match[1]}"`);
        }
      }
    }

    if (taps.length > 0) {
      filtered.push("# Taps");
      filtered.push(...taps);
      filtered.push("");
    }

    if (formulae.length > 0) {
      filtered.push("# Formulae");
      filtered.push(...formulae);
      filtered.push("");
    }

    if (casks.length > 0) {
      filtered.push("# Casks (GUI apps)");
      filtered.push(...casks);
      filtered.push("");
    }

    return filtered.join("\n");
  }

  private async importArchPackages(): Promise<ImportResult> {
    // Get explicitly installed packages
    const result = await exec("pacman -Qqe");
    
    if (!result.success) {
      return { success: false, message: "Failed to get package list: " + result.stderr };
    }

    const packages = result.stdout.split("\n").filter(Boolean);
    const essentialPackages = this.filterEssentialArchPackages(packages);

    ensureParentDir(this.repoPath);
    writeFileSync(this.repoPath, essentialPackages.join("\n") + "\n");

    return {
      success: true,
      message: "Generated packages.txt with essential packages",
      filesImported: ["packages.txt"],
    };
  }

  private filterEssentialArchPackages(packages: string[]): string[] {
    const essential = new Set([
      "git",
      "github-cli",
      "lazygit",
      "fnm-bin",
      "zoxide",
      "eza",
      "atuin",
      "go",
      "rbenv",
      "biome-bin",
      "aws-cli-v2",
    ]);

    const header = [
      "# packages.txt - Essential coding tools for Arch",
      "# Generated by ds - edit to customize",
      "# Install with: yay -S --needed - < packages.txt",
      "",
    ];

    const filtered = packages.filter(pkg => essential.has(pkg));
    
    return [...header, ...filtered];
  }

  async export(): Promise<ExportResult> {
    if (!this.existsInRepo()) {
      return { success: false, message: "Package file not found in repo" };
    }

    // Export means installing packages from the file
    return {
      success: true,
      message: "Use 'ds deps' to install packages from the package file",
    };
  }

  getStatus(): ConfigStatus {
    return {
      name: this.name,
      existsOnSystem: this.existsOnSystem(),
      existsInRepo: this.existsInRepo(),
      isLinked: false,
      hasDiff: false,
    };
  }
}

export const packagesConfig = new PackagesConfig();
